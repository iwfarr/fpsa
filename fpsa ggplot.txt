# ──────────────────────────────────────────────────────────────────────────────
# Flexible Parametric Survival Analysis (fpsa) on SAIL Databank via RODBC
# ──────────────────────────────────────────────────────────────────────────────

# 1. Load required packages
library(RODBC)        # for DB2 connection
library(flexsurv)     # for Royston–Parmar spline models
library(splines)      # for natural spline basis (ns())
library(dplyr)        # for data manipulation
library(ggplot2)      # for plotting

# 2. Connect to SAIL DB2 (DSN-less)
conn <- odbcDriverConnect(
  paste0(
    "Driver={IBM DB2 ODBC DRIVER};",
    "Database=db2data;",                     # your DB name
    "Hostname=db2.sail.ukserp.ac.uk;",       # SAIL host
    "Port=50000;",                           # DB2 default port
    "Protocol=TCPIP;",
    "Uid=YOUR_USERNAME;",                    # your SAIL username
    "Pwd=YOUR_PASSWORD;"                     # your SAIL password
  )
)

# 3. Pull the analysis dataset
sql <- "
  SELECT
    pyar,                    -- person-years at risk
    sh_ever_flag,            -- self-harm event indicator (0/1)
    smi_first_cond,          -- first SMI category
    camhs_prior_smi_diag,    -- prior CAMHS contact (0/1)
    gndr_cd,                 -- gender code (0/1)
    age_at_smi,              -- age at first SMI
    wimd_data_start          -- WIMD quintile (1–5)
  FROM your_schema.your_table
"
df <- sqlQuery(conn, sql)

# 4. Close the connection
close(conn)

# 5. Fit the Royston–Parmar spline model (3 knots)
fpsa <- flexsurvspline(
  formula = Surv(pyar, sh_ever_flag) ~
    smi_first_cond * camhs_prior_smi_diag * gndr_cd +
    ns(age_at_smi, df = 3) +
    wimd_data_start,
  data = df,
  k = 3
)

# 6. Specify the (coarse) time-grid for smooth curves
times <- seq(0, max(df$pyar, na.rm = TRUE), length.out = 150)

# 7. Build the pure covariate grid (no time column)
covgrid <- expand.grid(
  smi_first_cond       = levels(df$smi_first_cond),
  camhs_prior_smi_diag = c(FALSE, TRUE),
  gndr_cd              = c(0, 1),
  wimd_data_start      = levels(df$wimd_data_start),
  stringsAsFactors     = FALSE
) %>%
  transmute(
    smi_first_cond       = factor(smi_first_cond,
                                  levels = levels(df$smi_first_cond)),
    camhs_prior_smi_diag = as.logical(camhs_prior_smi_diag),
    gndr_cd              = as.numeric(gndr_cd),
    wimd_data_start      = factor(wimd_data_start,
                                  levels = levels(df$wimd_data_start)),
    age_at_smi           = median(df$age_at_smi, na.rm = TRUE)
  )

# 8. Vectorized hazard prediction *only* at our 150 times
ps_list <- summary(
  fpsa,
  newdata = covgrid,
  t       = times,
  type    = "hazard",
  se      = FALSE
)

# 9. Bind into one long data.frame, REPLICATING each covariate row
plot_df <- bind_rows(lapply(seq_along(ps_list), function(i) {
  d      <- as.data.frame(ps_list[[i]])
  n_time <- nrow(d)
  
  # replicate the i-th covrow to match n_time
  cv_rep <- covgrid[i, , drop = FALSE][rep(1, n_time), ]
  
  # attach time + covariates + estimate
  d$time <- times
  cbind(cv_rep, d)
}))

# 10. Plot smooth hazard curves
ggplot(plot_df,
       aes(x = time, y = est,
           colour   = smi_first_cond,
           linetype = wimd_data_start)) +
  geom_line(size = 1) +
  facet_grid(
    camhs_prior_smi_diag ~ gndr_cd,
    labeller = labeller(
      camhs_prior_smi_diag = c(`FALSE` = "No prior CAMHS",
                               `TRUE`  = "Prior CAMHS"),
      gndr_cd              = c(`0` = "Gender = 0",
                               `1` = "Gender = 1")
    )
  ) +
  scale_colour_brewer("SMI type",       palette = "Set1") +
  scale_linetype_brewer("WIMD quintile", palette = "Set2") +
  labs(
    x     = "Time since first SMI diagnosis (years)",
    y     = "Predicted hazard of self-harm",
    title = "Self-harm hazard curves by SMI type,\nstratified by CAMHS history, gender & deprivation"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom")
